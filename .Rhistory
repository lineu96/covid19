################################################################
# PAGINA 1
# trabalhando com um elemento da lista
a <- as.data.frame(out[1])
# renomeando colunas
nomes <- c("regional", "municipio", "confirmados", "obitos",
"descartados", "investigacao", "total")
names(a) <- nomes
# excluindo a primeira linha
a <- a[2:nrow(a),]
# corrigindo formato das colunas
a$regional <- as.vector(a$regional)
a$municipio <- as.vector(tolower(a$municipio))
a$confirmados <- as.numeric(a$confirmados)
a$obitos <- as.numeric(a$obitos)
a$descartados <- as.numeric(a$descartados)
a$investigacao <- as.numeric(a$investigacao)
a$total <- as.numeric(a$total)
str(a)
# corrigindo erro nas ultimas linhas (será que acontece em todos os casos?)
aux <- a[56:nrow(a),1:6]
aux <- cbind(rep("", nrow(aux)), aux)
names(aux) <- names(a)
a[56:nrow(a),] <- aux
# retirando a coluna de regional
a <- a[,2:ncol(a)]
# trabalhando com um elemento da lista
b <- as.data.frame(out[2])
# PAGINA 2
tail(b)
nrow(b)
b[60:71,]
# trabalhando com um elemento da lista
b <- as.data.frame(out[2])
library(pdftools)
install.packages("pdftools")
animate()
library(gganimate)
animate()
?animate()
options(gganimate.dev_args = list(width = 100, height = 100))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(tidyverse)    # programação eficiente
library(stringr)      # tratamento de strings
library(tabulizer)    # importação de tabelas em arquivos pdf
library(gifski)       # geração de gifs a partir de um conjunto de pngs
library(sp)           # classes e métodos para dados espaciais
library(maptools)     # ferramentas para lidar com objetos espaciais
library(RColorBrewer) # criação de paleta de cores para mapas temáticos
library(plotly)       # graficos dinamicos
library(gganimate)    # graficos animados
?animate
install.packages("stargazer")
library(stargazer)
attitude
stargazer(attitude)
?stargazer
stargazer(attitude, title = 'teste')
library(car)
ls("package:car")
?car::adaptiveKernel()
x<-rnorm(100)
car::adaptiveKernel(x)
car::densityPlot(x)
car::adaptiveKernel(x)
plot(car::adaptiveKernel(x))
car::densityPlot(x)
plot(car::adaptiveKernel(x))
?car::Anova()
134/4
134/6
134/2
134/3
134/4
134/5
134/7
134/8
134/9
134/10
134/3
134/5
funcoes <- ls("package:car")
134/5
data.frame(func = funcoes[1:27])
134/5
i <- 134/5
1+i
round(1+i)
data.frame(func = funcoes[1:round(1+i)],
func = funcoes[round(1+i):round(1+i+i)])
round(1+i+i+i)
round(1+i+i+i+i)
data.frame(func = funcoes[1:round(1+i)],
func = funcoes[round(1+i):round(1+i+i)],
func = funcoes[round(1+i+i):round(1+i+i+i)],
func = funcoes[round(1+i+i+i):round(1+i+i+i+i)],
func = funcoes[round(1+i+i+i+i):round(1+i+i+i+i+i)])
round(1+i+i+i+i+i)
data.frame(func = funcoes[1:round(1+i)],
func = funcoes[round(1+i):round(1+i+i)],
func = funcoes[round(1+i+i):round(1+i+i+i)],
func = funcoes[round(1+i+i+i):round(1+i+i+i+i)],
func = funcoes[round(1+i+i+i+i):round(1+i+i+i+i+i)-1])
(round(1+i+i+i+i+i)-1)
round(1+i+i+i+i):(round(1+i+i+i+i+i)-1)
data.frame(func = funcoes[1:round(1+i)],
func = funcoes[round(1+i):round(1+i+i)],
func = funcoes[round(1+i+i):round(1+i+i+i)],
func = funcoes[round(1+i+i+i):round(1+i+i+i+i)],
func = funcoes[round(1+i+i+i+i):(round(1+i+i+i+i+i)-1)])
funcoes[round(1+i+i+i+i):(round(1+i+i+i+i+i)-1)]
funcoes[round(1+i+i+i):round(1+i+i+i+i)]
funcoes[round(1+i+i):round(1+i+i+i)]
funcoes[round(1+i):round(1+i+i)]
funcoes[1:round(1+i)]
data.frame(func = funcoes[1:round(1+i)],
func = funcoes[round(1+i):round(1+i+i)],
func = funcoes[round(1+i+i):round(1+i+i+i)],
func = funcoes[round(1+i+i+i):round(1+i+i+i+i)],
func = funcoes[round(1+i+i+i+i):(round(1+i+i+i+i+i)-1)])
data.frame(func = funcoes[1:round(1+i)],
func = funcoes[round(1+i):round(1+i+i)],
func = funcoes[round(1+i+i):round(1+i+i+i)],
func = funcoes[round(1+i+i+i):round(1+i+i+i+i)],
func = funcoes[round(1+i+i+i+i):c(round(1+i+i+i+i+i), NA)])
data.frame(func = funcoes[1:round(1+i)],
func = funcoes[round(1+i):round(1+i+i)],
func = funcoes[round(1+i+i):round(1+i+i+i)],
func = funcoes[round(1+i+i+i):round(1+i+i+i+i)],
func = c(funcoes[round(1+i+i+i+i):(round(1+i+i+i+i+i)-1)], NA))
data.frame(func = funcoes[1:round(1+i)],
func = funcoes[round(1+i):round(1+i+i)],
func = funcoes[round(1+i+i):round(1+i+i+i)],
func = funcoes[round(1+i+i+i):round(1+i+i+i+i)]
)
data.frame(func = funcoes[1:round(1+i)],
func = funcoes[round(1+i):round(1+i+i)],
func = funcoes[round(1+i+i):round(1+i+i+i)],
func = funcoes[round(1+i+i+i):round(1+i+i+i+i)]
)
i
28+i
56+i
funcoes[1:27]
funcoes[28:55]
funcoes[28:54]
funcoes[55:82]
funcoes[55:81]
82+26
funcoes[82:108]
funcoes[108:134]
5*27
data.frame(func = funcoes[1:27],
func = funcoes[28:54],
func = funcoes[55:81],
func = funcoes[82:108],
func = funcoes[109:134])
data.frame(func = funcoes[1:27],
func = funcoes[28:54],
func = funcoes[55:81],
func = funcoes[82:108],
func = c(funcoes[109:134], NA))
funcoes <- data.frame(func = funcoes[1:27],
func = funcoes[28:54],
func = funcoes[55:81],
func = funcoes[82:108],
func = c(funcoes[109:134], NA))
funcoes <- ls("package:car")
funcoes[1]
# Nonparametric Density Estimates
carHexsticker()
# Nonparametric Density Estimates
?car::adaptiveKernel()
?car::Anova()
?car::Manova
?car::densityPlot()
?car::av.plot()
install.packages(car)
install.packages('car')
install.packages("car")
library(car)
funcoes <- ls("package:car")
funcoes
?car::Anova()
?car::av.plot()
?car::avPlot()
lm(prestige ~ income + education + type, data=Duncan)
avPlots(lm(prestige ~ income + education + type, data=Duncan))
avPlot(lm(prestige ~ income + education + type, data=Duncan))
avPlots(lm(prestige ~ income + education + type, data=Duncan))
car::avp(lm(prestige ~ income + education + type, data=Duncan))
?car::basicPower()
bcPower(U, lambda, jacobian.adjusted=FALSE, gamma=NULL)
car::avPlot()
car::avPlots()
?car::avPlots()
avPlots(lm(prestige ~ income + education + type, data=Duncan))
avPlots(glm(partic != "not.work" ~ hincome + children,
data=Womenlf, family=binomial), id=FALSE)
134-11
?car::basicPowerAxis()
UN
with(UN, plot(log(ppgdp, 10), log(infantMortality, 10)))
basicPowerAxis(0, base=10, side="above",
at=c(50, 200, 500, 2000, 5000, 20000), grid=TRUE,
axis.title="GDP per capita")
basicPowerAxis(0, base=10, side="right",
at=c(5, 10, 20, 50, 100), grid=TRUE,
axis.title="infant mortality rate per 1000")
?car::basicPowerAxis()
UN <- na.omit(UN)
par(mar=c(5, 4, 4, 4) + 0.1) # leave space on right
with(UN, plot(log(ppgdp, 10), log(infantMortality, 10)))
basicPowerAxis(0, base=10, side="above",
at=c(50, 200, 500, 2000, 5000, 20000), grid=TRUE,
axis.title="GDP per capita")
basicPowerAxis(0, base=10, side="right",
at=c(5, 10, 20, 50, 100), grid=TRUE,
axis.title="infant mortality rate per 1000")
with(UN, plot(bcPower(ppgdp, 0), bcPower(infantMortality, 0)))
bcPowerAxis(0, side="above",
grid=TRUE, axis.title="GDP per capita")
bcPowerAxis(0, side="right",
grid=TRUE, axis.title="infant mortality rate per 1000")
with(UN, qqPlot(logit(infantMortality/1000)))
probabilityAxis()
with(UN, qqPlot(qnorm(infantMortality/1000)))
probabilityAxis(at=c(.005, .01, .02, .04, .08, .16), scale="probit")
qqPlot(bcnPower(Ornstein$interlocks, lambda=1/3, gamma=0.1))
bcnPowerAxis(1/3, 0.1, at=c(o=0, 5, 10, 20, 40, 80))
qqPlot(bcnPower(Ornstein$interlocks, lambda=1/3, gamma=0.1))
bcnPowerAxis(1/3, 0.1, at=c(o=0, 5, 10, 20, 40, 80))
par(mar=c(5, 4, 4, 4) + 0.1) # leave space on right
with(UN, plot(log(ppgdp, 10), log(infantMortality, 10)))
basicPowerAxis(0, base=10, side="above",
at=c(50, 200, 500, 2000, 5000, 20000), grid=TRUE,
axis.title="GDP per capita")
basicPowerAxis(0, base=10, side="right",
at=c(5, 10, 20, 50, 100), grid=TRUE,
axis.title="infant mortality rate per 1000")
with(UN, plot(bcPower(ppgdp, 0), bcPower(infantMortality, 0)))
bcPowerAxis(0, side="above",
grid=TRUE, axis.title="GDP per capita")
bcPowerAxis(0, side="right",
grid=TRUE, axis.title="infant mortality rate per 1000")
with(UN, qqPlot(logit(infantMortality/1000)))
probabilityAxis()
with(UN, qqPlot(qnorm(infantMortality/1000)))
probabilityAxis(at=c(.005, .01, .02, .04, .08, .16), scale="probit")
qqPlot(bcnPower(Ornstein$interlocks, lambda=1/3, gamma=0.1))
bcnPowerAxis(1/3, 0.1, at=c(o=0, 5, 10, 20, 40, 80))
UN <- na.omit(UN)
par(mar=c(5, 4, 4, 4) + 0.1) # leave space on right
with(UN, plot(log(ppgdp, 10), log(infantMortality, 10)))
basicPowerAxis(0, base=10, side="above",
at=c(50, 200, 500, 2000, 5000, 20000), grid=TRUE,
axis.title="GDP per capita")
basicPowerAxis(0, base=10, side="right",
at=c(5, 10, 20, 50, 100), grid=TRUE,
axis.title="infant mortality rate per 1000")
with(UN, plot(bcPower(ppgdp, 0), bcPower(infantMortality, 0)))
bcPowerAxis(0, side="above",
grid=TRUE, axis.title="GDP per capita")
bcPowerAxis(0, side="right",
grid=TRUE, axis.title="infant mortality rate per 1000")
?car::Boot()
lm(Fertility ~ ., swiss)
m1 <- lm(Fertility ~ ., swiss)
betahat.boot <- Boot(m1, R=199) # 199 bootstrap samples--too small to be useful
Boot(m1, R=199)
summary(betahat.boot)  # default summary
confint(betahat.boot)
hist(betahat.boot)
# Bootstrap for the estimated residual standard deviation:
sigmahat.boot <- Boot(m1, R=199, f=sigmaHat, labels="sigmaHat")
summary(sigmahat.boot)
confint(sigmahat.boot)
confint(sigmahat.boot)
plot(betahat.boot)
plot(sigmahat.boot)
hist(sigmahat.boot)
?car::Anova()
?car::bootCase()
car::bootCase()
?car::bootCase()
?car::boxCox()
with(trees, boxCox(Volume ~ log(Height) + log(Girth), data = trees,
lambda = seq(-0.25, 0.25, length = 10)))
data("quine", package = "MASS")
with(quine, boxCox(Days ~ Eth*Sex*Age*Lrn,
lambda = seq(-0.05, 0.45, len = 20), family="yjPower"))
?car::boxCox()
?car::boxCox2d()
?car::boxCox2d()
car::boxCoxVariable()
?car::boxCoxVariable()
?car::boxCoxVariable()
mod <- lm(interlocks + 1 ~ assets, data=Ornstein)
mod
mod.aux <- update(mod, . ~ . + boxCoxVariable(interlocks + 1))
mod.aux
summary(mod.aux)
avPlots(mod.aux, "boxCoxVariable(interlocks + 1)")
?car::Boxplot()
Boxplot(~income, data=Prestige, id=list(n=Inf)) # identify all outliers
Boxplot(income ~ type, data=Prestige)
Boxplot(income ~ type, data=Prestige, at=c(1, 3, 2))
Boxplot(k5 + k618 ~ lfp*wc, data=Mroz)
with(Prestige, Boxplot(income, id=list(labels=rownames(Prestige))))
with(Prestige, Boxplot(income, type, id=list(labels=rownames(Prestige))))
Boxplot(scale(Prestige[, 1:4]))
Boxplot(~income, data=Prestige, id=list(n=Inf)) # identify all outliers
Boxplot(income ~ type, data=Prestige)
Boxplot(income ~ type, data=Prestige, at=c(1, 3, 2))
Boxplot(k5 + k618 ~ lfp*wc, data=Mroz)
Mroz
Boxplot(income ~ type, data=Prestige)
Boxplot(~income, data=Prestige, id=list(n=Inf)) # identify all outliers
Boxplot(~income, data=Prestige, id=list(n=Inf)) # identify all outliers
Boxplot(income, data=Prestige, id=list(n=Inf)) # identify all outliers
with(Prestige, Boxplot(income, id=list(labels=rownames(Prestige))))
with(Prestige, Boxplot(income, type, id=list(labels=rownames(Prestige))))
with(Prestige, Boxplot(income, id=list(labels=rownames(Prestige))))
with(Prestige, Boxplot(income, type, id=list(labels=rownames(Prestige))))
Boxplot(scale(Prestige[, 1:4]))
Boxplot(income ~ type, data=Prestige)
Boxplot(income ~ type, data=Prestige, at=c(1, 3, 2))
Boxplot(income ~ type, data=Prestige)
Boxplot(income ~ type, data=Prestige)
Boxplot(income ~ type, data=Prestige, at=c(1, 3, 2))
Boxplot(income ~ type, data=Prestige)
Boxplot(income ~ type, data=Prestige, at=c(1, 3, 2))
Boxplot(k5 + k618 ~ lfp*wc, data=Mroz)
Mroz
Boxplot(~income, data=Prestige, id=list(n=Inf)) # identify all outliers
Boxplot(income ~ type, data=Prestige)
Boxplot(k5 + k618 ~ lfp*wc, data=Mroz)
with(Prestige, Boxplot(income, id=list(labels=rownames(Prestige))))
with(Prestige, Boxplot(income, type, id=list(labels=rownames(Prestige))))
Boxplot(scale(Prestige[, 1:4]))
Boxplot(income ~ type, data=Prestige)
Boxplot(k5 + k618 ~ lfp*wc, data=Mroz)
par(mfrow = c(1,2))
Boxplot(income ~ type, data=Prestige)
Boxplot(k5 + k618 ~ lfp*wc, data=Mroz)
funcoes
paste0('car::',funcoes)
noquote(paste0('car::',funcoes))
?car::av.plot
134 - 124
134 - 24
?car::bootCase
?car::av.plot
?car::boxTidwell
boxTidwell(prestige ~ income + education, ~ type + poly(women, 2),
data=Prestige)
A<-boxTidwell(prestige ~ income + education, ~ type + poly(women, 2),
data=Prestige)
plot(A)
plot(A$result)
plot(A$iterations)
?car::brief
brief(rnorm(100))
brief(Duncan)
brief(OBrienKaiser, elided=TRUE)
brief(matrix(1:500, 10, 50))
brief(lm)
mod.prestige <- lm(prestige ~ education + income + type, Prestige)
brief(mod.prestige, pvalues=TRUE)
?car::carHexsticker
?car::carPalette
?car::carWeb
#car::carHexsticker
#car::carPalette
?car::carWeb
#car::carHexsticker
#car::carPalette
car::carWeb
#car::carHexsticker
#car::carPalette
car::carWeb()
?car::av.plot
?car::av.plots
?car::bc
?car::bootCase
?car::box.cox
?car::box.cox.powers
?car::box.cox.var
?car::box.tidwell
?car::ceres.plot
?car::ceres.plots
?car::confidence.ellipse
?car::coOKd
?car::cooKd
?car::cookd
?car::cr.plot
?car::cr.plots
?car::data.ellipse
?car::durbin.watson
?car::levene.test
?car::leverage.plot
?car::leverage.plots
?car::ncv.test
?car::nextBoot
?car::ceresPlot
ceresPlots(lm(prestige~income+education+type, data=Prestige), terms= ~ . - type)
?car::compareCoefs
mod1 <- lm(prestige ~ income + education, data=Duncan)
mod2 <- update(mod1, subset=-c(6,16))
mod3 <- update(mod1, . ~ . + type)
mod4 <- update(mod1, . ~ . + I(income + education)) # aliased coef.
compareCoefs(mod1)
compareCoefs(mod1, mod2, mod4)
compareCoefs(mod1, mod2, mod3, zvals=TRUE, pvals=TRUE)
?car::confidenceEllipse
dataEllipse(Duncan$income, Duncan$education, levels=0.1*1:9,
ellipse.label=0.1*1:9, lty=2, fill=TRUE, fill.alpha=0.1)
dataEllipse(Duncan$income, Duncan$education, levels=0.1*1:9,
ellipse.label=0.1*1:9, lty=2, fill=TRUE, fill.alpha=0.1)
confidenceEllipse(lm(prestige~income+education, data=Duncan), Scheffe=TRUE)
confidenceEllipse(lm(prestige~income+education, data=Duncan), vcov.=hccm)
confidenceEllipse(lm(prestige~income+education, data=Duncan),
L=c("income + education", "income - education"))
wts <- rep(1, nrow(Duncan))
wts[c(6, 16)] <- 0 # delete Minister, Conductor
with(Duncan, {
dataEllipse(income, prestige, levels=0.68)
dataEllipse(income, prestige, levels=0.68, robust=TRUE,
plot.points=FALSE, col="green3")
dataEllipse(income, prestige, weights=wts, levels=0.68,
plot.points=FALSE, col="brown")
dataEllipse(income, prestige, weights=wts, robust=TRUE, levels=0.68,
plot.points=FALSE, col="blue")
})
with(Prestige, dataEllipse(income, education, type,
id=list(n=2, labels=rownames(Prestige)), pch=15:17,
xlim=c(0, 25000), center.pch="+",
group.labels=c("Blue Collar", "Professional", "White Collar"),
ylim=c(5, 20), level=.95, fill=TRUE, fill.alpha=0.1))
dataEllipse(Duncan$income, Duncan$education, levels=0.1*1:9,
ellipse.label=0.1*1:9, lty=2, fill=TRUE, fill.alpha=0.1)
confidenceEllipse(lm(prestige~income+education, data=Duncan), Scheffe=TRUE)
dataEllipse(Duncan$income, Duncan$education, levels=0.1*1:9,
ellipse.label=0.1*1:9, lty=2, fill=TRUE, fill.alpha=0.1)
confidenceEllipse(lm(prestige~income+education, data=Duncan), Scheffe=TRUE)
confidenceEllipse(lm(prestige~income+education, data=Duncan), vcov.=hccm)
confidenceEllipse(lm(prestige~income+education, data=Duncan),
L=c("income + education", "income - education"))
wts <- rep(1, nrow(Duncan))
wts[c(6, 16)] <- 0 # delete Minister, Conductor
with(Duncan, {
dataEllipse(income, prestige, levels=0.68)
dataEllipse(income, prestige, levels=0.68, robust=TRUE,
plot.points=FALSE, col="green3")
dataEllipse(income, prestige, weights=wts, levels=0.68,
plot.points=FALSE, col="brown")
dataEllipse(income, prestige, weights=wts, robust=TRUE, levels=0.68,
plot.points=FALSE, col="blue")
})
with(Prestige, dataEllipse(income, education, type,
id=list(n=2, labels=rownames(Prestige)), pch=15:17,
xlim=c(0, 25000), center.pch="+",
group.labels=c("Blue Collar", "Professional", "White Collar"),
ylim=c(5, 20), level=.95, fill=TRUE, fill.alpha=0.1))
par(mfrow = c(2,3))
par(mfrow = c(2,3))
dataEllipse(Duncan$income, Duncan$education, levels=0.1*1:9,
ellipse.label=0.1*1:9, lty=2, fill=TRUE, fill.alpha=0.1)
confidenceEllipse(lm(prestige~income+education, data=Duncan), Scheffe=TRUE)
confidenceEllipse(lm(prestige~income+education, data=Duncan), vcov.=hccm)
confidenceEllipse(lm(prestige~income+education, data=Duncan),
L=c("income + education", "income - education"))
wts <- rep(1, nrow(Duncan))
wts[c(6, 16)] <- 0 # delete Minister, Conductor
with(Duncan, {
dataEllipse(income, prestige, levels=0.68)
dataEllipse(income, prestige, levels=0.68, robust=TRUE,
plot.points=FALSE, col="green3")
dataEllipse(income, prestige, weights=wts, levels=0.68,
plot.points=FALSE, col="brown")
dataEllipse(income, prestige, weights=wts, robust=TRUE, levels=0.68,
plot.points=FALSE, col="blue")
})
with(Prestige, dataEllipse(income, education, type,
id=list(n=2, labels=rownames(Prestige)), pch=15:17,
xlim=c(0, 25000), center.pch="+",
group.labels=c("Blue Collar", "Professional", "White Collar"),
ylim=c(5, 20), level=.95, fill=TRUE, fill.alpha=0.1))
?car::Confint
mod.prestige <- lm(prestige ~ education + income + type, Prestige)
mod.prestige
mod.prestige <- lm(prestige ~ education + income + type, Prestige)
mod.prestige
S(mod.prestige, vcov.=hccm)
S(mod.prestige, brief=TRUE)
Confint(mod.prestige, vcov.=hccm)
?car::contr.Helmert
?car::crp
crPlots(m<-lm(prestige ~ income + education, data=Prestige))
crPlots(m, terms=~ . - education) # get only one plot
crPlots(lm(prestige ~ log2(income) + education + poly(women,2), data=Prestige))
crPlots(glm(partic != "not.work" ~ hincome + children,
data=Womenlf, family=binomial), smooth=list(span=0.75))
crPlots(lm(prestige ~ log2(income) + education + poly(women,2), data=Prestige))
crPlots(glm(partic != "not.work" ~ hincome + children,
data=Womenlf, family=binomial), smooth=list(span=0.75))
?car::dbiwt
?car::depan
?car::deltaMethod
134-68
setwd("~/covid19")
rmarkdown::render_site()
